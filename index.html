<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Melexis.IO</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Bootstrap 5 CDN -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
  <link href="/styles/melexis.css" rel="stylesheet">
  
  
  <style>
    body {
      font-family: var(--mx-font-sans);
      margin: 0;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      background-color: var(--mx-bg); 
      color: var(--mx-white);
      background-image: url("/styles/background.jpg"); 
      background-repeat: no-repeat; 
      background-size: cover; 
      background-position: center center; 
      background-attachment: fixed; 
    }
    
    #header {
        display: flex;
        justify-content: space-between;
        justify-content: center;
        margin-bottom: 20px;
        padding: 10px;
        background: transparent;
        color: #FFFFFF;
    }

    /* App area */
    #app {
      display: flex;
      flex: 1 1 auto;
      min-height: 0;
    }

    .muted { opacity: 1; font-size: 14px; color: var(--mx-white); }

    #historyList {
      display: flex; flex-direction: column; gap: .25rem; max-height: 40vh; overflow: auto; margin-top: .25rem;
    }

    .hist-item {
      text-align: left; padding: .35rem .5rem; border: 1px solid var(--mx-border); background: var(--mx-surface);
      border-radius: 2px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      color: var(--mx-white);
    }

    .hist-item:hover { background: rgba(255,255,255,0.12); }

    #main {
      flex: 1 1 auto;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    fieldset { 
      padding: 5px;
      background: transparent; 
      border:1px solid var(--mx-electric-green); 
    }

    legend { padding: 0 .5rem; font-weight:600; }

    .bootstrap-tabs { margin-top: 6px; }
    /* Remove custom tab styling (handled by Bootstrap) */
    .bootstrap-tabs .nav-link { cursor: pointer; }

      /* Fixed-height log with scrollbars */
    #log {
      width: 100%;
      height: 45vh;      /* reduced to 50% viewport height */
      max-height: calc(100vh - 260px); /* safeguard relative to other UI */
      box-sizing: border-box;
      white-space: pre-wrap;          /* preserve newlines */
      overflow-wrap: anywhere;        /* allow breaks inside long tokens */
      word-break: break-word;         /* fallback for older engines */
      overflow: auto;    /* scrollbars when content expands */
      border: 1px solid var(--mx-white);
      padding: .5rem;
      background: var(--mx-white); /* black background for log */
      color: var(--mx-black);       /* default: response (RX) gray */
      font-family: 'Lato', ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 14px;
    }

      /* Color coding for log entries */
    .log-echo { color: var(--mx-royal-blue-600) }    /* brighter blue for local echo (TX) */
    .log-rx   { color: var(--mx-black) }    /* light gray for device response (RX) */
    .log-okprompt { color: var(--mx-electric-green) }/* bright mint for "(OK)>" prompts */
    .log-badprompt { color: var(--mx-coral-red) }/* softer red for non-OK prompts */
    .log-error { color: var(--mx-coral-red-800)  }   /* vivid error red */

    #row { display: flex; gap: .5rem; margin-top: .5rem; flex-wrap: wrap; }

    input[type="text"] { flex: 1 1 320px; }

    .controls { display: flex; gap: .5rem; flex-wrap: wrap; align-items: center; margin:4px; }

    .spacer { flex: 1 1 auto; }

    button { cursor: pointer; }
    /* Compact TX bar */
    .tx-bar .btn, .tx-bar .form-control { padding-top: .2rem; padding-bottom: .2rem; line-height: 1.0; }
    .tx-bar { min-height: 0; }
    /* Themed elements */
    .btn-primary { background-color: var(--mx-electric-green-800); }
    .btn-primary:hover, .btn-primary:focus { background-color: var(--mx-electric-green);}
    .btn.btn-primary.w-100 { margin-bottom: 0.4rem;}
    .btn-secondary { background-color: var(--mx-steel-grey);  color: var(--mx-white); }
    .btn-secondary:hover { background-color: #9bb1b8; }
    .btn-success { background: var(--mx-electric-green); color:#0B1D3A; }
    .btn-success:hover { background: #8fd6c7; }
    .btn-outline-primary { color: var(--mx-white); }
    .btn-outline-primary:hover { background: var(--mx-royal-blue); color:#E8ECF7; }
    .btn-outline-danger { color: var(--mx-error); }
    .btn-outline-danger:hover { background: var(--mx-error); color:#FFFFFF; }
    .btn-outline-secondary { color: var(--mx-text-muted);}
    .btn-outline-secondary:hover { background: var(--mx-border); color:#E8ECF7; }
    .btn-outline-warning { color: var(--mx-warning); border-color: var(--mx-warning); }
    .btn-outline-warning:hover { background: var(--mx-warning); color:#3a2d00; }
    .btn-outline-info { color: var(--mx-link); }
    .btn-outline-info:hover { background: var(--mx-link); color:#002a38; }

    .nav-tabs { 
      border-color: transparent;
    }

    .nav-tabs .nav-link {
      color: var(--mx-white);
      background: transparent;
      border: 1px solid transparent;
      border-top-left-radius: 2px;
      border-top-right-radius: 2px;
    }

    

    .nav-tabs .nav-link.active {
      color: #FFFFFF;
      background: var(--mx-electric-green-800);
      border-color: var(--mx-electric-green-800) var(--mx-electric-green-800) transparent;
      box-shadow: 0 2px 0 0 var(--mx-electric-green-800);
    }

    .nav-tabs .nav-link:hover {
      color: var(--mx-white);
      background: var(--mx-electric-green);
      border-color: transparent;
    }

    .tab-content {
      background: transparent;
      border-top: none;
      padding: .5rem .5rem;
      border-radius: 0 0 2px 2px;
      /* Fit within page and allow scrolling when overflowing */
      max-height: calc(100vh - 260px);
      overflow: auto;
    }

    .form-control { 
      background: var(--mx-white); 
      border:1px solid var(--mx-white); 
      color: var(--mx-black); 
    }
    .form-control:focus { 
      background: var(--mx-white); 
      color:var(--mx-black); 
      border-color: var(--mx-electric-green); 
      box-shadow:0 0 0 .15rem rgba(101,187,169,0.25); 
    }
    .form-control:disabled {
      background: var(--mx-white) !important;
      color: var(--mx-black) !important;
      opacity: 1 !important; /* avoid dimming text */
      border-color: var(--mx-electric-green) !important;
    }

    .form-select {
      border:1px solid var(--mx-white); 
      color: var(--mx-black); 
    }
    .form-select:focus{
      color: var(--mx-black); 
      border-color: var(--mx-electric-green); 
      box-shadow:0 0 0 .15rem rgba(101,187,169,0.25); 
    }
    .form-select:disabled{
      color: var(--mx-black) !important;
      opacity: 1 !important; /* avoid dimming text */
      border-color: transparent !important;
    }


    /* Chromium/WebKit sometimes ignores color on disabled text */
    input.form-control:disabled::-webkit-text-fill-color { color:#3e4242; }

    /* Placeholder tint when disabled */
    .form-control:disabled::placeholder { color:#b2c4cb; }

    input::placeholder { color:#b2c4cb; }

    hr { border-color: var(--mx-border); }
      select, input[type="number"] { width: 8rem; }
      @media (max-width: 800px) {
        #sidebar { width: 180px; }
        select, input[type="number"] { width: 7rem; }
      }
      .section-title { margin: 0 0 .5rem 0; font-weight: 600; }

    hr {
    height: 2px;
    background-color: var(--mx-electric-green); /* A nice blue color */
    width: 50%; /* Only 50% of the container width */
    margin: 20px auto; /* Add vertical space and auto-center horizontally */
    }

    .container-flex-col {
      display: flex;
      flex-direction: column;
      align-items: center; 
      gap: 10px; 
      width: 140px;
    }

    /* Style for the copyright bar */
    .footer-bottom {
      color: #fff;
      font-size: 14px;
      position: relative;
      text-align: center;
      z-index: 2;
    }

    #resend {
      width: 120px;
      text-align: center;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 5px;
    }

    #irRunning {
      width:10px;
      height:10px;
      border-radius:50%;
      background:var(--mx-steel-grey);
      box-shadow:0 0 4px #0D1A2B;
      transition:background-color .2s, box-shadow .2s;
    }
 
  </style>

</head>
<body>
  <header id="header">
    <div style="display: flex; gap: 20px; align-items: center; margin-right: auto;">
      <button id="connect" class="btn btn-primary btn-sm">Connect</button>
      <button id="disconnect" class="btn btn-primary btn-sm" disabled>Disconnect</button>
    </div>
    <div>
      <span class="banner" style="font-weight:600;font-size:2.4rem;letter-spacing:.03em;">Melexis.IO</span>
    </div>
    <div style="display: flex; gap: 20px; align-items: center; margin-left: auto;">
          <span id="status" class="muted small"></span>
    </div>
  </header>
  <div id="app">
  <main id="main">
    <ul class="nav nav-tabs bootstrap-tabs" id="mainTabs" role="tablist">
      <li class="nav-item" role="presentation">
        <button class="nav-link active" id="terminal-tab" data-bs-toggle="tab" data-bs-target="#tab1" type="button" role="tab" aria-controls="tab1" aria-selected="true">Terminal</button>
      </li>
      <li class="nav-item" role="presentation">
        <button class="nav-link" id="settings-tab" data-bs-toggle="tab" data-bs-target="#tab2" type="button" role="tab" aria-controls="tab2" aria-selected="false">Settings</button>
      </li>
    </ul>
    <div class="tab-content pt-3" id="mainTabsContent">
      <div class="tab-pane fade show active" id="tab1" role="tabpanel" aria-labelledby="terminal-tab">
        <div style="display: flex; flex-wrap: wrap; gap: 2rem; align-items: flex-start;">
          <div style="flex:1 1 0;min-width:320px;">
            <div id="log" aria-live="polite"></div>
            <div id="row" class="d-flex flex-column gap-2">
              <div class="d-flex flex-nowrap align-items-center gap-1 w-100 tx-bar">
                <button id="clear" class="btn btn-primary btn-sm" >Clear</button>
                <button id="save" class="btn btn-primary btn-sm" >Save</button>
                <input id="tx" class="form-control form-control-sm" type="text" placeholder="Type command to send" style="flex:1 1 auto;" />
                <button id="send" class="btn btn-primary btn-sm" disabled>Send</button>
              </div>
              <hr />   
              <div class="d-flex" >
                <div class="container-flex-col">
                  <h3>History</h3>
                  <button id="clear-history" class="btn btn-primary btn-sm" >Clear History</button>
                  <button id="resend" class="btn btn-primary btn-sm" disabled>Resend</button>
                </div>
                <select id="historyCombo" class="form-select form-select-sm" size="2" aria-live="polite" title="Command history"></select>
              </div>              
            </div>
          </div>
          <div id="sidebar" style="min-width:150px;max-width:150px;flex:0 0 0;padding:0 1rem 0 0;border:0;">
            <h3>Commands</h3>
            <button id="cmd-id" class="btn btn-primary w-100 btn-sm" title='Send "*IDN?"' disabled>Id</button>
            <button id="cmd-info" class="btn btn-primary w-100 btn-sm" title='Send ":SYST:INFO"' disabled>Info</button>
            <button id="cmd-log" class="btn btn-primary w-100 btn-sm" title='Send ":SYST:LOG"' disabled>Log</button>
            <button id="cmd-help" class="btn btn-primary w-100 btn-sm" title='Send ":SYST:HELP"' disabled>Help</button>
            <button id="cmd-rst" class="btn btn-primary w-100 btn-sm" title='Send "*RST"' disabled>Reset</button>
          </div>
        </div>
      </div>
      <div class="tab-pane fade" id="tab2" role="tabpanel" aria-labelledby="settings-tab">
        <div class="p-3"> 
          <h5 class="mb-2">Settings</h5>
          <div class="row g-3">   
            <div class="col-12 col-lg-6">
              <fieldset class="p-2" style="border-radius:2px;">
                <legend class="float-none w-auto px-2 small mb-0">Connection</legend>
                <div class="d-flex flex-wrap align-items-end gap-3 p-2">
                  <label class="form-label mb-0">Baud:
                    <input id="baud" class="form-control form-control-sm" type="number" value="115200" min="50" step="50" />
                  </label>
                  <label class="form-label mb-0">Data bits:
                    <select id="databits" class="form-select form-select-sm">
                      <option>8</option>
                      <option selected>7</option>
                    </select>
                  </label>
                  <label class="form-label mb-0">Parity:
                    <select id="parity" class="form-select form-select-sm">
                      <option value="none">none</option>
                      <option value="even">even</option>
                      <option value="odd" selected>odd</option>
                    </select>
                  </label>
                  <label class="form-label mb-0">Stop bits:
                    <select id="stopbits" class="form-select form-select-sm">
                      <option>1</option>
                      <option selected>2</option>
                    </select>
                  </label> 
                  <label class="form-label mb-0">Flow:
                    <select id="flow" class="form-select form-select-sm">
                      <option value="none" selected>none</option>
                      <option value="hardware">hardware (RTS/CTS)</option>
                    </select>
                  </label>
                  <p class="small mt-2 mb-0">Baud rate, data bits, parity, stop bits, and flow control selections are saved and restored (localStorage).</p>
                </div>
              </fieldset>
            </div>
            <div class="col-12 col-lg-6">
              <fieldset class="p-2 mb-3" style="border-radius:2px;">
                <legend class="float-none w-auto px-2 small mb-0">Input options</legend>
                <div class="d-flex flex-wrap align-items-center gap-3 p-2">  
                  <label class="form-label mb-0 d-flex align-items-center gap-1"> EOL:
                    <select id="eol" class="form-select form-select-sm" title="End-of-line to append on send" style="max-width:100px;">
                      <option value="">No EOL</option>
                      <option value="\n" selected>LF</option>
                      <option value="\r">CR</option>
                      <option value="\r\n">CRLF</option>
                    </select>
                  </label>  
                  <label class="form-check form-check-inline mb-0">
                    <input id="echo" class="form-check-input" type="checkbox" checked /><span class="form-check-label"> Local echo</span>
                  </label> 
                  <label class="form-check form-check-inline mb-0">
                    <input id="enterSend" class="form-check-input" type="checkbox" checked /><span class="form-check-label"> Enter sends</span>
                  </label>
                  <label class="form-check form-check-inline mb-0">
                    <input id="autoScroll" class="form-check-input" type="checkbox" checked /><span class="form-check-label"> Auto-scroll</span>
                  </label>
                </div>
              </fieldset>
            </div>
            <div class="col-12 col-lg-6">
              <fieldset class="p-2" style="border-radius:2px;">
                <legend class="float-none w-auto px-2 small mb-0">Actions</legend>
                <div class="d-flex flex-wrap align-items-center gap-2 mt-1">
                  <button id="resetSerialSettings" class="btn btn-primary btn-sm">Reset to defaults</button>
                  <button id="exportSettings" class="btn btn-primary btn-sm" title="Download settings bundle (commands + parameters + IR)">Export settings</button>
                  <button id="importSettings" class="btn btn-primary btn-sm" title="Import settings bundle JSON">Import settings</button>
                  <button id="eepromSave" class="btn btn-primary btn-sm" title="Save current settings to device EEPROM" disabled>Save to EEPROM</button>
                  <button id="eepromLoad" class="btn btn-primary btn-sm" title="Load settings from device EEPROM" disabled>Load from EEPROM</button>
                  <input id="importSettingsFile" type="file" accept="application/json" style="display:none;" />
                </div>
              </fieldset>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Thermal Viewer now opens as a separate page (isp/index.html); -->
    </div>
  </main>
  </div>

  <footer>   
      <hr class="green-line" />
      <div class="footer-bottom">
          <p>Copyright &copy; 2025 Melexis. All rights reserved. <a href="https://www.melexis.com/en/legal/terms-of-use" class="muted" style="margin:0px 7.5px;">Terms of use</a> <a href="help.html" class="muted" style="margin-right:7.5px;">Help</a> <a href="firmware.html" class="muted" style="margin-right:7.5px;">Firmware Update</a> <a href="help/html/index.html" class="muted" target="_blank" rel="noopener noreferrer">SCPI Commands</a></p>
      </div>
  </footer>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
  
  
  
  <script>
  // Serial
  let port, reader, writer, reading = false;
  // Enhanced status info
  let connPortLabel = '';
  let awaitingIdnFirstLine = false;
  let connDescription = '';
  let textDecoder, textEncoder;
  let readableStreamClosed, writableStreamClosed;
  // Track last connected VID:PID for reconnection use
  let lastConnectedVidPid = null;

    // History (cookie-backed) — only for input #tx
    const HISTORY_COOKIE = 'mip_cmd_history';
    const HISTORY_MAX = 100;
    const HISTORY_SHOW = 20;
    // Newest-first order: history[0] is most recent
    let history = [];
    let historyIndex = -1;       // -1 = not navigating
    let draftBeforeNav = '';

    const $ = (id) => document.getElementById(id);
    const logEl = $('log');
    // Log performance controls
    const LOG_MAX_CHARS = 500000;   // hard cap to avoid unbounded DOM/memory (~0.5M chars)
    const LOG_TRIM_TO  = 400000;    // trim down to this when exceeding cap
    let logTotalChars = 0;          // running total of chars in #log (approx)
    let logQueue = [];              // pending entries to append { text, cls }
    let logFlushScheduled = false;  // RAF scheduled flag
    function scheduleLogFlush() {
      if (!logFlushScheduled) {
        logFlushScheduled = true;
        requestAnimationFrame(flushLog);
      }
    }
    function flushLog() {
      logFlushScheduled = false;
      if (!logQueue.length) return;
      const frag = document.createDocumentFragment();
      // Coalesce adjacent same-class chunks to reduce node count
      let prevCls = null;
      let buf = '';
      const commit = () => {
        if (!buf) return;
        const span = document.createElement('span');
        if (prevCls) span.className = prevCls;
        span.textContent = buf;
        span.dataset.len = String(buf.length);
        frag.appendChild(span);
        logTotalChars += buf.length;
        buf = '';
      };
      for (const it of logQueue) {
        const cls = it.cls || '';
        if (cls === prevCls) {
          buf += it.text;
        } else {
          commit();
          prevCls = cls;
          buf = it.text;
        }
      }
      commit();
      logQueue.length = 0;
      logEl.appendChild(frag);
      // Trim if beyond cap
      if (logTotalChars > LOG_MAX_CHARS) {
        while (logTotalChars > LOG_TRIM_TO && logEl.firstChild) {
          const n = logEl.firstChild;
          let len = 0;
          if (n.dataset && n.dataset.len) {
            len = parseInt(n.dataset.len, 10) || 0;
          }
          if (!len) {
            // fallback: compute length once
            len = (n.textContent && n.textContent.length) || 0;
          }
          logTotalChars -= len;
          logEl.removeChild(n);
        }
      }
      if ($('autoScroll').checked) logEl.scrollTop = logEl.scrollHeight;
    }

    /* ===== Serial settings persistence ===== */
    const SERIAL_SETTINGS_KEY = 'mip_serial_settings_v1';
    const SERIAL_DEFAULTS = { baud: 115200, databits: 7, parity: 'odd', stopbits: 2, flow: 'none' };

    function loadSerialSettings() {
      try {
        const raw = localStorage.getItem(SERIAL_SETTINGS_KEY);
        if (!raw) return { ...SERIAL_DEFAULTS };
        const obj = JSON.parse(raw);
        return { ...SERIAL_DEFAULTS, ...(obj && typeof obj === 'object' ? obj : {}) };
      } catch { return { ...SERIAL_DEFAULTS }; }
    }
    function saveSerialSettings(obj) {
      try { localStorage.setItem(SERIAL_SETTINGS_KEY, JSON.stringify(obj)); } catch {}
    }
    function currentSerialSettings() {
      return {
        baud: parseInt($('baud').value,10)||SERIAL_DEFAULTS.baud,
        databits: parseInt($('databits').value,10)||SERIAL_DEFAULTS.databits,
        parity: $('parity').value || SERIAL_DEFAULTS.parity,
        stopbits: parseInt($('stopbits').value,10)||SERIAL_DEFAULTS.stopbits,
        flow: $('flow').value || SERIAL_DEFAULTS.flow,
      };
    }
    function applySerialSettings(obj) {
      if (!obj) return;
      $('baud').value = obj.baud;
      $('databits').value = String(obj.databits);
      $('parity').value = obj.parity;
      $('stopbits').value = String(obj.stopbits);
      $('flow').value = obj.flow;
    }
    function persistAndDisplay() { saveSerialSettings(currentSerialSettings()); }
    /* ===== Input option persistence ===== */
    const INPUT_OPTIONS_KEY = 'mip_input_options_v1';
  // Input defaults: use literal escaped sequences ("\\n", "\\r", "\\r\\n")
  // so they directly match <option value> attributes. Previously this was an
  // actual newline which failed to select the LF option on load/reset.
  const INPUT_DEFAULTS = { eol: '\\n', echo: true, enterSend: true, autoScroll: true };
    function loadInputOptions() {
      try {
        const raw = localStorage.getItem(INPUT_OPTIONS_KEY);
        if (!raw) return { ...INPUT_DEFAULTS };
        const obj = JSON.parse(raw);
        return { ...INPUT_DEFAULTS, ...(obj && typeof obj === 'object' ? obj : {}) };
      } catch { return { ...INPUT_DEFAULTS }; }
    }
    function applyInputOptions(obj) {
      if (!obj) return;
      // Normalize legacy stored actual control chars to escaped forms expected by the select.
      if (obj.eol === '\n') obj.eol = '\\n';
      else if (obj.eol === '\r') obj.eol = '\\r';
      else if (obj.eol === '\r\n') obj.eol = '\\r\\n';
      if ($('eol')) $('eol').value = (obj.eol ?? INPUT_DEFAULTS.eol);
      if ($('echo')) $('echo').checked = !!obj.echo;
      if ($('enterSend')) $('enterSend').checked = !!obj.enterSend;
      if ($('autoScroll')) $('autoScroll').checked = !!obj.autoScroll;
    }
    function saveInputOptions() {
      try {
        const snap = {
          eol: $('eol') ? $('eol').value : INPUT_DEFAULTS.eol,
          echo: $('echo') ? $('echo').checked : INPUT_DEFAULTS.echo,
          enterSend: $('enterSend') ? $('enterSend').checked : INPUT_DEFAULTS.enterSend,
          autoScroll: $('autoScroll') ? $('autoScroll').checked : INPUT_DEFAULTS.autoScroll
        };
        localStorage.setItem(INPUT_OPTIONS_KEY, JSON.stringify(snap));
      } catch {}
    }
    // Attach listeners for input options
    ['eol','echo','enterSend','autoScroll'].forEach(id => {
      const el = $(id); if (!el) return;
      el.addEventListener('change', saveInputOptions);
      if (el.tagName === 'SELECT') el.addEventListener('input', saveInputOptions);
    });
    // Load stored input options now
    const _loadedInputOptions = loadInputOptions();
    applyInputOptions(_loadedInputOptions);
    // Attach change listeners (delegated after DOM ready; elements already exist inline)
    ['baud','databits','parity','stopbits','flow'].forEach(id => {
      const el = $(id);
      if (el) el.addEventListener('change', persistAndDisplay);
      if (el && el.tagName === 'INPUT') el.addEventListener('input', persistAndDisplay);
    });
    // Load on startup
    const _loadedSerial = loadSerialSettings();
    applySerialSettings(_loadedSerial);
    // Provide reset button logic (in Settings tab)
    document.addEventListener('DOMContentLoaded', () => {
      const resetBtn = $('resetSerialSettings');
      if (resetBtn) resetBtn.addEventListener('click', () => {
        // Reset serial connection settings
        applySerialSettings(SERIAL_DEFAULTS);
        persistAndDisplay();
        // Reset input option settings (EOL, echo, enter, auto-scroll) to defaults
        applyInputOptions({ ...INPUT_DEFAULTS });
        saveInputOptions();
      });
      // Start with IR controls disabled until connected
      const irRead = $('irRead'); if (irRead) irRead.disabled = true;
      const irCont = $('irContinuous'); if (irCont) irCont.disabled = true;
      const expBtn = $('exportSettings');
      if (expBtn) expBtn.addEventListener('click', exportSettingsJson);
      const impBtn = $('importSettings');
      const impFile = $('importSettingsFile');
      if (impBtn && impFile) {
        impBtn.addEventListener('click', () => impFile.click());
        impFile.addEventListener('change', () => {
          const f = impFile.files && impFile.files[0];
          if (f) importSettingsJsonFile(f);
          impFile.value = '';
        });
      }
      const eepromSaveBtn = $('eepromSave');
      if (eepromSaveBtn) eepromSaveBtn.addEventListener('click', () => alert('TODO: EEPROM save (implement device command)'));
      const eepromLoadBtn = $('eepromLoad');
      if (eepromLoadBtn) eepromLoadBtn.addEventListener('click', () => alert('TODO: EEPROM load (implement device command)'));
      // summary removed
      // Initialize status hint for users before connecting
      setStatus('Disconnected');
    });

    // Cookie utils (no regex to avoid escaping issues)
    function readCookie(name) {
      const prefix = name + '=';
      const parts = document.cookie ? document.cookie.split(';') : [];
      for (const part of parts) {
        const s = part.trim();
        if (s.startsWith(prefix)) {
          return decodeURIComponent(s.slice(prefix.length));
        }
      }
      return '';
    }
    function writeCookie(name, value, maxAgeSec) {
      document.cookie = name + '=' + encodeURIComponent(value) + '; path=/; max-age=' + maxAgeSec.toString();
    }
    function deleteCookie(name) {
      document.cookie = name + '=; path=/; max-age=0';
    }

    // History helpers
    function loadHistory() {
      try {
        const v = readCookie(HISTORY_COOKIE);
        if (!v) return [];
        const arr = JSON.parse(v);
        return Array.isArray(arr) ? arr.filter(s => typeof s === 'string') : [];
      } catch { return []; }
    }
    function saveHistory() {
      // Trim oldest items (at the end) to cap size
      while (history.length > HISTORY_MAX) history.pop();
      try {
        writeCookie(HISTORY_COOKIE, JSON.stringify(history), 60 * 60 * 24 * 365);
      } catch {
        while (history.length > Math.min(25, HISTORY_MAX)) history.pop();
        try { writeCookie(HISTORY_COOKIE, JSON.stringify(history), 60 * 60 * 24 * 365); } catch {}
      }
    }
    function addToHistory(cmd) {
      const c = (cmd ?? '').trim();
      if (!c) return;
      if (history[0] === c) return; // avoid immediate dup (top)
      // Newest-first: add to the top
      history.unshift(c);
      saveHistory();
      renderHistory();
    }
    function clearHistory() {
      history = [];
      deleteCookie(HISTORY_COOKIE);
      renderHistory();
    }
    function renderHistory() {
      const combo = $('historyCombo');
      if (!combo) return;
      combo.innerHTML = '';
      const end = Math.min(history.length, HISTORY_SHOW);
      for (let i = 0; i < end; i++) {
        const cmd = history[i];
        const opt = document.createElement('option');
        opt.value = cmd;
        opt.textContent = cmd;
        combo.appendChild(opt);
      }
    }

    /* ===== Settings Export / Import (commands + connection + IR + input options) ===== */
    function exportSettingsJson() {
      const payload = {
        type: 'melexis.io-settings',
        version: 5,
        exportedAt: new Date().toISOString(),
        history: [...history],
        historyCount: history.length,
        serialSettings: currentSerialSettings(),
        ir: { autoScale: irAutoScale, min: irManualMin, max: irManualMax, scale: irScale },
        input: {
          eol: $('eol') ? $('eol').value : '',
          echo: $('echo') ? $('echo').checked : false,
          enterSend: $('enterSend') ? $('enterSend').checked : false,
          autoScroll: $('autoScroll') ? $('autoScroll').checked : false
        }
      };
      const blob = new Blob([JSON.stringify(payload, null, 2)], {type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      const ts = new Date().toISOString().replace(/[:.]/g,'-');
      a.download = `settings-${ts}.json`;
      document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(url);
    }
    function importSettingsJsonFile(file) {
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const text = e.target.result;
          const obj = JSON.parse(text);
          if (!obj || !(obj.type === 'melexis.io-settings' || obj.type === 'melexis.io-history') || !Array.isArray(obj.history)) {
            alert('Invalid settings file.');
            return;
          }
          const arr = obj.history.filter(s => typeof s === 'string' && s.trim().length > 0);
          history = arr.slice(0, HISTORY_MAX);
          saveHistory();
          renderHistory();
          if (obj.serialSettings && typeof obj.serialSettings === 'object') {
            try {
              const merged = { ...SERIAL_DEFAULTS, ...obj.serialSettings };
              applySerialSettings(merged);
              persistAndDisplay();
            } catch {}
          }
          if (obj.ir && typeof obj.ir === 'object') {
            if (obj.ir.autoScale !== undefined || obj.ir.min !== undefined || obj.ir.max !== undefined || obj.ir.scale !== undefined) {
              // New format (v5)
              if (typeof obj.ir.autoScale === 'boolean') irAutoScale = obj.ir.autoScale;
              if (typeof obj.ir.min === 'number') irManualMin = obj.ir.min;
              if (typeof obj.ir.max === 'number') irManualMax = obj.ir.max;
              if (obj.ir.scale === 1 || obj.ir.scale === 2 || obj.ir.scale === 4) irScale = obj.ir.scale;
              try {
                const autoCb = $('irAutoScale'); if (autoCb) autoCb.checked = irAutoScale;
                const minEl = $('irMinInput'); if (minEl) minEl.value = (isNaN(irManualMin)?IR_MIN:irManualMin).toFixed(2);
                const maxEl = $('irMaxInput'); if (maxEl) maxEl.value = (isNaN(irManualMax)?IR_MAX:irManualMax).toFixed(2);
                const sel = $('irScaleSelect'); if (sel) sel.value = String(irScale);
                if (typeof updateIrScaleInputsEnabled === 'function') updateIrScaleInputsEnabled();
              } catch {}
              try { if (typeof saveIrSettings === 'function') saveIrSettings(); } catch {}
              if (irInitialized) renderIr();
            } else if (obj.ir.scale === 1 || obj.ir.scale === 2 || obj.ir.scale === 4) {
              // Legacy (v4) where only scale is present
              irScale = obj.ir.scale;
              const sel = $('irScaleSelect'); if (sel) sel.value = String(irScale);
              try { if (typeof saveIrSettings === 'function') saveIrSettings(); } catch {}
              if (irInitialized) renderIr();
            }
          }
          if (obj.input && typeof obj.input === 'object') {
            applyInputOptions(obj.input);
            saveInputOptions();
          }
          alert('Imported settings. Commands: ' + history.length + (obj.serialSettings ? ', connection parameters applied' : '') + (obj.ir ? ', IR scale applied' : ''));
        } catch (err) {
          console.error('Import failed', err);
          alert('Failed to import: ' + err.message);
        }
      };
      reader.readAsText(file);
    }
    // Legacy wrappers (if any old references remain)
    function exportHistoryJson(){ exportSettingsJson(); }
    function importHistoryJsonFile(f){ importSettingsJsonFile(f); }

    function setStatus(msg) { $('status').textContent = msg || ''; }
    function updateConnectedStatus() {
      const statusBase = 'Connected';
      // const descParts = connDescription.split(',');
      // const descLabel = connDescription ? ' – ' + descParts[3] : '';
      setStatus(statusBase);
      const st = $('status');
      if (st) {
        st.title = [
          'USB device: ' + (connPortLabel || 'unknown'),
          connDescription || null,
          'Note: OS COM port name/path not exposed by Web Serial'
        ].filter(Boolean).join('\n');
      }
    }

    // Format port info (where available) as USB VID:PID hex
    function formatPortLabel(p) {
      try {
        if (!p || typeof p.getInfo !== 'function') return '';
        const info = p.getInfo();
        if (!info) return '';
        const { usbVendorId, usbProductId, serialNumber } = info;
        let parts = [];
        if (typeof usbVendorId === 'number' && typeof usbProductId === 'number') {
          parts.push('0x' + usbVendorId.toString(16).padStart(4,'0').toUpperCase() + ':' + '0x' + usbProductId.toString(16).padStart(4,'0').toUpperCase());
        }
        if (serialNumber) parts.push(serialNumber);
        return parts.length ? parts.join(' ') : '';
      } catch { return ''; }
    }

    // Logging helpers (span-based to support colors)
    function appendLog(text, cls) {
      if (!text) return;
      logQueue.push({ text, cls });
      // Throttle DOM work to animation frame to keep UI responsive
      scheduleLogFlush();
    }
    function logEcho(text) { appendLog(text, 'log-echo'); }
    function logError(text) { appendLog(text, 'log-error'); }

    // Stream RX processing: color prompts only at real start-of-line,
    // do not inject any markers. Works across chunk boundaries.
    let atLineStart = true;
    // Accumulate partial line content across reads until EOL encountered
    let _rxLineBuffer = '';
  function processRx(text) {
      let i = 0;
      while (i < text.length) {
        // If at start of a line, check for prompt "(...)>"
        if (atLineStart) {
          const slice = text.slice(i);
          const m = slice.match(/^\(([^)]+)\)>/);
          if (m) {
            const cls = m[1] === 'OK' ? 'log-okprompt' : 'log-badprompt';
            appendLog(m[0], cls);
            try { _notifyPromptWaiters(m[0]); } catch {}
            i += m[0].length;
            atLineStart = false;
            continue;
          }
        }
        // Append up to and including next EOL (\n or \r). Treat CRLF as single EOL.
        const nl = text.indexOf('\n', i);
        const cr = text.indexOf('\r', i);
        let end = -1;
        if (nl === -1) end = cr;
        else if (cr === -1) end = nl;
        else end = Math.min(nl, cr);
        if (end === -1) {
          const tail = text.slice(i);
          appendLog(tail, 'log-rx');
          // Accumulate partial line for waiter matching on next chunk
          _rxLineBuffer += tail;
          atLineStart = false;
          break;
        } else {
          // Include CRLF as a single segment
          const advance = (text[end] === '\r' && text[end + 1] === '\n') ? 2 : 1;
          const seg = text.slice(i, end + advance);
          appendLog(seg, 'log-rx');
          // Combine with any buffered partial from previous read()
          const lineBody = (_rxLineBuffer + seg).replace(/[\r\n]+$/, '');
          _rxLineBuffer = '';
          // notify any line waiters with the raw line (without trailing EOL)
          try { _notifyLineWaiters(lineBody); } catch {}
          try { maybeHandleIrModeLine(lineBody); } catch {}
          try { maybeHandleIrContinuousFrame(lineBody); } catch {}
          if (awaitingIdnFirstLine) {
            const body = lineBody.trim();
            if (body && body.toLowerCase() !== '*idn?' && !/^\(.*\)>$/.test(body)) {
              connDescription = body;
              awaitingIdnFirstLine = false;
              updateConnectedStatus();
            }
          }
          i = end + advance;
          atLineStart = true;
        }
      }
    }

    // Decode literal option values ("\n", "\r", "\r\n") into actual control chars
    function eolValue() {
      const v = $('eol').value;
      if (v === '\\n') return '\n';
      if (v === '\\r') return '\r';
      if (v === '\\r\\n') return '\r\n';
      return '';
    }
    function setCommandButtonsEnabled(enabled) {
      $('cmd-id').disabled = !enabled;
      $('cmd-info').disabled = !enabled;
      $('cmd-log').disabled = !enabled;
      $('cmd-help').disabled = !enabled;
      $('cmd-rst').disabled = !enabled;
      const es = $('eepromSave'); if (es) es.disabled = !enabled;
      const elb = $('eepromLoad'); if (elb) elb.disabled = !enabled;
      // IR tab controls follow connection state
      const irCont = $('irContinuous');
      const irContActive = irCont && irCont.getAttribute('data-active') === '1';
      const irRead = $('irRead'); if (irRead) irRead.disabled = !enabled || !!irContActive;
      if (irCont) {
        irCont.disabled = !enabled;
        if (!enabled) {
          // If disabling while continuous is active, stop it and reset UI.
          // This relies on IR script having initialized; if not, these DOM ops are harmless.
          if (irCont.getAttribute('data-active') === '1') {
            irCont.setAttribute('data-active','0');
            irCont.classList.remove('btn-success');
            irCont.classList.add('btn-outline-secondary');
          }
          // Clear any running timer if available (guarded in try in case IR section not parsed yet)
          try { if (irContinuousTimer) { clearInterval(irContinuousTimer); irContinuousTimer = null; } } catch {}
          try { refreshIrRunningIndicator(); } catch {}
          // Stop and disable recording controls if disconnected
          try { if (irRec && irRec.active) stopIrRecording(); } catch {}
          const recStart = $('irRecStart'); if (recStart) recStart.disabled = true;
          const recStop = $('irRecStop'); if (recStop) recStop.disabled = true;
        }
      }
      // When connected, sync recording buttons state with continuous
      try { updateIrRecordingButtons(); } catch {}
      
    }

  async function connect() {
      if (!('serial' in navigator)) {
        alert('Web Serial API not supported in this browser. Use Chrome or Edge (desktop).');
        return;
      }
      try {
        // Always request a new port
        port = await navigator.serial.requestPort();
        try {
          const info = port && typeof port.getInfo === 'function' ? port.getInfo() : null;
          if (info && typeof info.usbVendorId === 'number' && typeof info.usbProductId === 'number') {
            lastConnectedVidPid = { vid: info.usbVendorId, pid: info.usbProductId };
          }
        } catch {}
        const opts = {
          baudRate: parseInt($('baud').value, 10) || 115200,
          dataBits: parseInt($('databits').value, 10) || 7,
          stopBits: parseInt($('stopbits').value, 10) || 2,
          parity: $('parity').value || 'odd',
          flowControl: $('flow').value || 'none',
        };
        await port.open(opts);

  textDecoder = new TextDecoderStream();
  textEncoder = new TextEncoderStream();

  // Keep references to piping promises so we can await them on disconnect
  readableStreamClosed = port.readable.pipeTo(textDecoder.writable);
  writableStreamClosed = textEncoder.readable.pipeTo(port.writable);

        reader = textDecoder.readable.getReader();
        writer = textEncoder.writable.getWriter();

    $('connect').disabled = true;
    $('disconnect').disabled = false;
    $('send').disabled = false;
    $('cmd-id').disabled = false;
    $('cmd-info').disabled = false;
    $('cmd-log').disabled = false;
    $('cmd-help').disabled = false;
    $('cmd-rst').disabled = false;
    $('resend').disabled = false;
    setCommandButtonsEnabled(true);
    connPortLabel = formatPortLabel(port);
    connDescription = '';
    awaitingIdnFirstLine = true; // will capture first *IDN? response line
    updateConnectedStatus();

        // Auto query on connect (not recorded in history)
        await sendCommand('*idn?');

        reading = true;
        (async () => {
          try {
            while (reading) {
              const { value, done } = await reader.read();
              if (done) break;
              if (value) processRx(value);
            }
          } catch (err) {
            console.error('Read error:', err);
            setStatus('Read error: ' + err.message);
          } finally {
            try { reader.releaseLock(); } catch {}
          }
        })();

      } catch (err) {
        console.error('Connect failed:', err);
        alert('Failed to connect: ' + err.message);
        setStatus('Disconnected. Works in Chrome/Edge desktop. Requires HTTPS or localhost. Only one app can hold the port at a time.');
        setCommandButtonsEnabled(false);
      }
    }

    // Connect using filters or previously granted ports matching VID:PID
    async function connectWithFilters(vid, pid) {
      if (!('serial' in navigator)) {
        alert('Web Serial API not supported in this browser. Use Chrome or Edge (desktop).');
        return;
      }
      try {
        // Try previously granted ports first for a silent re-connect
        port = null;
        try {
          const ports = await navigator.serial.getPorts();
          for (const p of ports) {
            const info = p && typeof p.getInfo === 'function' ? p.getInfo() : null;
            if (info && info.usbVendorId === vid && info.usbProductId === pid) { port = p; break; }
          }
        } catch {}
        if (!port) {
          port = await navigator.serial.requestPort({ filters: [{ usbVendorId: vid, usbProductId: pid }] });
        }
        try { lastConnectedVidPid = { vid, pid }; } catch {}
        const opts = {
          baudRate: parseInt($('baud').value, 10) || 115200,
          dataBits: parseInt($('databits').value, 10) || 7,
          stopBits: parseInt($('stopbits').value, 10) || 2,
          parity: $('parity').value || 'odd',
          flowControl: $('flow').value || 'none',
        };
        await port.open(opts);

        textDecoder = new TextDecoderStream();
        textEncoder = new TextEncoderStream();
        readableStreamClosed = port.readable.pipeTo(textDecoder.writable);
        writableStreamClosed = textEncoder.readable.pipeTo(port.writable);
        reader = textDecoder.readable.getReader();
        writer = textEncoder.writable.getWriter();

        $('connect').disabled = true;
        $('disconnect').disabled = false;
        $('send').disabled = false;
        $('cmd-id').disabled = false;
        $('cmd-info').disabled = false;
        $('cmd-log').disabled = false;
        $('cmd-help').disabled = false;
        $('cmd-rst').disabled = false;
        $('resend').disabled = false;
        setCommandButtonsEnabled(true);
        connPortLabel = formatPortLabel(port);
        connDescription = '';
        awaitingIdnFirstLine = true;
        updateConnectedStatus();
        await sendCommand('*idn?');

        reading = true;
        (async () => {
          try {
            while (reading) {
              const { value, done } = await reader.read();
              if (done) break;
              if (value) processRx(value);
            }
          } catch (err) {
            console.error('Read error:', err);
            setStatus('Read error: ' + err.message);
          } finally {
            try { reader.releaseLock(); } catch {}
          }
        })();
      } catch (err) {
        console.error('Connect (filtered) failed:', err);
        alert('Failed to connect: ' + err.message);
        setStatus('Disconnected. Works in Chrome/Edge desktop. Requires HTTPS or localhost. Only one app can hold the port at a time.');
        setCommandButtonsEnabled(false);
      }
    }

    async function disconnect() {
      try {
        setStatus('Disconnecting…');
        reading = false;
        // Stop reading
        try {
          if (reader) {
            await reader.cancel();
            try { reader.releaseLock && reader.releaseLock(); } catch {}
          }
        } catch {}
        // Stop writing
        try {
          if (writer) {
            await writer.close();
            try { writer.releaseLock && writer.releaseLock(); } catch {}
          }
        } catch {}
        // Wait for the piping to finish
        try { if (readableStreamClosed) await readableStreamClosed.catch(() => {}); } catch {}
        try { if (writableStreamClosed) await writableStreamClosed.catch(() => {}); } catch {}
        // Finally close the port
        try { if (port) await port.close(); } catch {}
      } finally {
        // Do not set port to null, so it can be reused
        reader = null;
        writer = null;
        readableStreamClosed = null;
        writableStreamClosed = null;
        textDecoder = null;
        textEncoder = null;
        $('connect').disabled = false;
        $('disconnect').disabled = true;
        $('send').disabled = true;
        $('cmd-id').disabled = true;
        $('cmd-info').disabled = true;
        $('cmd-log').disabled = true;
        $('cmd-help').disabled = true;
        $('cmd-rst').disabled = true;
        $('resend').disabled = true;
        setCommandButtonsEnabled(false);
        connPortLabel = '';
        connDescription = '';
        awaitingIdnFirstLine = false;
        setStatus('Disconnected');
      }
    }

    async function send() {
      if (!writer) { setStatus('Not connected'); return; }
      const raw = $('tx').value;
      const text = raw + eolValue();
      try {
        await writer.write(text);
        addToHistory(raw); // only add from input tx
        if ($('echo').checked) logEcho(text);
        $('tx').value = '';
        historyIndex = -1; draftBeforeNav = '';
        $('tx').focus();
      } catch (err) {
        console.error('Write error:', err);
        setStatus('Write error: ' + err.message);
      }
    }

    async function sendCommand(cmd) {
      if (!writer) { setStatus('Not connected'); return; }
      const text = cmd + eolValue();
      try {
        await writer.write(text);
        // Do NOT add to history here (buttons and auto commands excluded)
        if ($('echo').checked) logEcho(text);
      } catch (err) {
        console.error('Write error:', err);
        setStatus('Write error: ' + err.message);
      }
    }

  // Await specific device line responses (normalized without trailing CR/LF)
    const _lineWaiters = [];
    // Keep a small backlog of recent complete lines to avoid race conditions
    // if a response arrives before a waiter is registered.
    const RX_LAST_LINES_MAX = 200;
    const _rxLastLines = [];
    function _notifyLineWaiters(line) {
      // iterate from end to allow safe splice
      for (let i = _lineWaiters.length - 1; i >= 0; i--) {
        const w = _lineWaiters[i];
        try {
          if (w.predicate(line)) {
            _lineWaiters.splice(i, 1);
            try { clearTimeout(w.timeoutId); } catch {}
            w.resolve(line);
          }
        } catch {}
      }
      // Record in backlog (cap size)
      _rxLastLines.push(line);
      if (_rxLastLines.length > RX_LAST_LINES_MAX) _rxLastLines.shift();
    }
    function waitForLineExact(expected, timeoutMs = 3000) {
      // First, check recent backlog in case the line already arrived.
      for (let i = _rxLastLines.length - 1; i >= 0; i--) {
        if (_rxLastLines[i] === expected) {
          return Promise.resolve(_rxLastLines[i]);
        }
      }
      return new Promise((resolve, reject) => {
        const predicate = (line) => line === expected;
        const timeoutId = setTimeout(() => {
          // remove from array if still present
          for (let i = _lineWaiters.length - 1; i >= 0; i--) {
            if (_lineWaiters[i].resolve === resolve) { _lineWaiters.splice(i, 1); }
          }
          reject(new Error('Timed out waiting for "' + expected + '"'));
        }, timeoutMs);
        _lineWaiters.push({ predicate, resolve, reject, timeoutId });
      });
    }
    function waitForLineStartsWith(prefix, timeoutMs = 5000) {
      // Check backlog first
      for (let i = _rxLastLines.length - 1; i >= 0; i--) {
        if (_rxLastLines[i].startsWith(prefix)) {
          return Promise.resolve(_rxLastLines[i]);
        }
      }
      return new Promise((resolve, reject) => {
        const predicate = (line) => line.startsWith(prefix);
        const timeoutId = setTimeout(() => {
          for (let i = _lineWaiters.length - 1; i >= 0; i--) {
            if (_lineWaiters[i].resolve === resolve) { _lineWaiters.splice(i, 1); }
          }
          reject(new Error('Timed out waiting for line starting with "' + prefix + '"'));
        }, timeoutMs);
        _lineWaiters.push({ predicate, resolve, reject, timeoutId });
      });
    }
    function waitForLineRegex(regex, timeoutMs = 5000) {
      // Check backlog first
      for (let i = _rxLastLines.length - 1; i >= 0; i--) {
        if (regex.test(_rxLastLines[i])) {
          return Promise.resolve(_rxLastLines[i]);
        }
      }
      return new Promise((resolve, reject) => {
        const predicate = (line) => regex.test(line);
        const timeoutId = setTimeout(() => {
          for (let i = _lineWaiters.length - 1; i >= 0; i--) {
            if (_lineWaiters[i].resolve === resolve) { _lineWaiters.splice(i, 1); }
          }
          reject(new Error('Timed out waiting for line matching ' + regex));
        }, timeoutMs);
        _lineWaiters.push({ predicate, resolve, reject, timeoutId });
      });
    }

    // Prompt waiters: detect lines like "(OK)>" that are parsed separately from line bodies
    const _promptWaiters = [];
    const PROMPT_LAST_MAX = 50;
    const _rxLastPrompts = [];
    function _notifyPromptWaiters(promptText) {
      for (let i = _promptWaiters.length - 1; i >= 0; i--) {
        const w = _promptWaiters[i];
        try {
          if (w.predicate(promptText)) {
            _promptWaiters.splice(i, 1);
            try { clearTimeout(w.timeoutId); } catch {}
            w.resolve(promptText);
          }
        } catch {}
      }
      _rxLastPrompts.push(promptText);
      if (_rxLastPrompts.length > PROMPT_LAST_MAX) _rxLastPrompts.shift();
    }
    function waitForPromptExact(expected, timeoutMs = 3000) {
      for (let i = _rxLastPrompts.length - 1; i >= 0; i--) {
        if (_rxLastPrompts[i] === expected) return Promise.resolve(_rxLastPrompts[i]);
      }
      return new Promise((resolve, reject) => {
        const predicate = (p) => p === expected;
        const timeoutId = setTimeout(() => {
          for (let i = _promptWaiters.length - 1; i >= 0; i--) {
            if (_promptWaiters[i].resolve === resolve) { _promptWaiters.splice(i, 1); }
          }
          reject(new Error('Timed out waiting for prompt ' + expected));
        }, timeoutMs);
        _promptWaiters.push({ predicate, resolve, reject, timeoutId });
      });
    }

    function parseMvLineToFrame(line) {
      // Expect: mv:XX:DDD:fp,fp,fp,... (769 floats). Ignore first float; use next 768 floats for 32x24 grid.
      // Be tolerant of wrapping quotes and whitespace.
      let s = (line || '').trim();
      if (s.length >= 2 && s.startsWith('"') && s.endsWith('"')) {
        s = s.slice(1, -1);
      }
      const m = s.match(/^mv:([0-9A-Fa-f]{2}):([0-9]+):(.+)$/);
      if (!m) throw new Error('Bad mv line format');
      const hexCode = m[1];
      const timestampMs = parseInt(m[2], 10);
      const csv = m[3];
      const parts = csv.split(',');
      if (parts.length < 769) throw new Error('Expected 769 floats, got ' + parts.length);
      const out = new Float32Array(IR_ROWS * IR_COLS);
      for (let i = 0; i < IR_ROWS * IR_COLS; i++) {
        const v = parseFloat(parts[i + 1]); // skip first value
        out[i] = isNaN(v) ? 0 : v;
      }
      return { codeHex: hexCode, timestampMs, frame: out };
    }

    async function sendRaw(text) {
      if (!writer) { setStatus('Not connected'); throw new Error('Not connected'); }
      try {
        await writer.write(text);
        if ($('echo').checked) logEcho(text);
      } catch (err) {
        console.error('Write error:', err);
        setStatus('Write error: ' + err.message);
        throw err;
      }
    }

  function clearLog() { logEl.textContent = ''; logTotalChars = 0; logQueue.length = 0; logFlushScheduled = false; }

    function saveLog() {
      const blob = new Blob([logEl.textContent], { type: 'text/plain;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      const ts = new Date().toISOString().replace(/[:.]/g, '-');
      a.download = `serial-log-${ts}.txt`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    // Events
    $('connect').addEventListener('click', connect);
    $('disconnect').addEventListener('click', disconnect);
    $('send').addEventListener('click', send);
    $('clear').addEventListener('click', clearLog);
    $('save').addEventListener('click', saveLog);

    $('cmd-id').addEventListener('click', () => sendCommand('*IDN?'));
  $('cmd-info').addEventListener('click', () => sendCommand(':SYST:INFO'));
  $('cmd-log').addEventListener('click', () => sendCommand(':SYST:LOG'));
  $('cmd-help').addEventListener('click', () => sendCommand(':SYST:HELP'));
    $('cmd-rst').addEventListener('click', async () => {
      try {
        await sendCommand('*RST');
        // Wait for reset indication then OK prompt
        try { await waitForLineExact('*RESET*', 10000); } catch {}
        try { await waitForPromptExact('(OK)>', 8000); } catch {}
      } finally {
        try { await disconnect(); } catch {}
        // Wait 5 seconds
        await new Promise(r => setTimeout(r, 5000));
        // Reconnect using same VID:PID if known
        if (lastConnectedVidPid && typeof lastConnectedVidPid.vid === 'number' && typeof lastConnectedVidPid.pid === 'number') {
          try { await connectWithFilters(lastConnectedVidPid.vid, lastConnectedVidPid.pid); }
          catch (err) { setStatus('Reconnect failed: ' + (err && err.message ? err.message : String(err))); }
        } else {
          setStatus('Reconnect skipped: unknown VID:PID');
        }
      }
    });

    // Arrow Up/Down history navigation in input (newest-first order)
    $('tx').addEventListener('keydown', (e) => {
      if ($('enterSend').checked && e.key === 'Enter') {
        e.preventDefault();
        $('send').click();
        return;
      }
      if (e.key === 'ArrowUp') {
        e.preventDefault();
        if (history.length === 0) return;
        if (historyIndex === -1) {
          draftBeforeNav = $('tx').value;
          historyIndex = 0; // most recent
        } else {
          historyIndex = Math.min(history.length - 1, historyIndex + 1); // go to older
        }
        $('tx').value = history[historyIndex] ?? '';
        $('tx').setSelectionRange($('tx').value.length, $('tx').value.length);
      } else if (e.key === 'ArrowDown') {
        e.preventDefault();
        if (history.length === 0) return;
        if (historyIndex === -1) {
          // nothing
        } else if (historyIndex > 0) {
          historyIndex--;
          $('tx').value = history[historyIndex] ?? '';
        } else {
          historyIndex = -1;
          $('tx').value = draftBeforeNav;
        }
        $('tx').setSelectionRange($('tx').value.length, $('tx').value.length);
      }
    });
    $('tx').addEventListener('input', () => {
      if (historyIndex !== -1) historyIndex = -1;
    });

    $('clear-history').addEventListener('click', clearHistory);

    window.addEventListener('beforeunload', disconnect);

    // Init history on load
    history = loadHistory();
    renderHistory();

  </script>
  <script>
    // History combo wiring: populate from global `history` and allow resend
    document.addEventListener('DOMContentLoaded', () => {
      const combo = document.getElementById('historyCombo');
      const clearBtn = document.getElementById('clear-history');
      const resendBtn = document.getElementById('resend');
      const tx = document.getElementById('tx');
      const sendBtn = document.getElementById('send');

      function refreshCombo() {
        if (!combo || !Array.isArray(history)) return;
        combo.innerHTML = '';
        history.slice(0, HISTORY_SHOW).forEach(item => {
          const opt = document.createElement('option');
          opt.value = item;
          opt.textContent = item;
          combo.appendChild(opt);
        });
      }

      // Initial fill
      refreshCombo();

      // When user clears history (existing logic handles storage), refresh the combo
      if (clearBtn) {
        clearBtn.addEventListener('click', () => setTimeout(refreshCombo, 100));
      }

      // Update TX when selection changes
      if (combo) {
        combo.addEventListener('change', () => {
          if (tx) tx.value = combo.value || '';
        });
        // Allow double-click to resend immediately
        combo.addEventListener('dblclick', () => {
          if (tx) tx.value = combo.value || '';
          if (sendBtn) sendBtn.click();
        });
      }

      // Resend selected item
      if (resendBtn) {
        resendBtn.addEventListener('click', () => {
          if (!combo) return;
          if (tx) tx.value = combo.value || '';
          if (sendBtn) sendBtn.click();
        });
      }

      // Re-render the combo whenever history updates
      const originalRender = window.renderHistory;
      if (typeof originalRender === 'function') {
        window.renderHistory = function() {
          originalRender.apply(this, arguments);
          refreshCombo();
        };
      }
    });
  </script>
</body>
</html>
